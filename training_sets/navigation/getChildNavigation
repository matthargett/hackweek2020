import getChildRouter from './getChildRouter';<EOL>import getNavigationActionCreators from './routers/getNavigationActionCreators';<EOL>import getChildrenNavigationCache from './getChildrenNavigationCache';<EOL>import getEventManager from './getEventManager';<EOL><EOL>const createParamGetter = (route) => (paramName, defaultValue) => {<EOL> const params = route.params;<EOL><EOL> if (params && paramName in params) {<EOL> return params[paramName];<EOL> }<EOL><EOL> return defaultValue;<EOL>};<EOL><EOL>function getChildNavigation(navigation, childKey, getCurrentParentNavigation) {<EOL> const children = getChildrenNavigationCache(navigation);<EOL> const childRoute = navigation.state.routes.find((r) => r.key === childKey);<EOL><EOL> if (!childRoute) {<EOL> return null;<EOL> }<EOL><EOL> if (children[childKey] && children[childKey].state === childRoute) {<EOL> return children[childKey];<EOL> }<EOL><EOL> const childRouter = getChildRouter(navigation.router, childRoute.routeName);<EOL><EOL> <EOL> <EOL> <EOL> <EOL> <EOL> const focusedGrandChildRoute =<EOL> childRoute.routes && typeof childRoute.index === 'number'<EOL> ? childRoute.routes[childRoute.index]<EOL> : null;<EOL><EOL> const actionCreators = {<EOL> ...navigation.actions,<EOL> ...navigation.router.getActionCreators(childRoute, navigation.state.key),<EOL> ...(childRouter<EOL> ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)<EOL> : {}),<EOL> ...getNavigationActionCreators(childRoute),<EOL> };<EOL><EOL> const actionHelpers = {};<EOL> Object.keys(actionCreators).forEach((actionName) => {<EOL> actionHelpers[actionName] = (...args) => {<EOL> const actionCreator = actionCreators[actionName];<EOL> const action = actionCreator(...args);<EOL> return navigation.dispatch(action);<EOL> };<EOL> });<EOL><EOL> let isFirstRouteInParent = true;<EOL><EOL> const parentNavigation = getCurrentParentNavigation();<EOL><EOL> if (parentNavigation) {<EOL> isFirstRouteInParent =<EOL> parentNavigation.state.routes.indexOf(childRoute) === 0;<EOL> }<EOL><EOL> if (<EOL> children[childKey] &&<EOL> children[childKey].isFirstRouteInParent() === isFirstRouteInParent<EOL> ) {<EOL> children[childKey] = {<EOL> ...children[childKey],<EOL> ...actionHelpers,<EOL> state: childRoute,<EOL> router: childRouter,<EOL> actions: actionCreators,<EOL> getParam: createParamGetter(childRoute),<EOL> };<EOL> return children[childKey];<EOL> } else {<EOL> const { addListener, emit } = getEventManager(childKey);<EOL><EOL> children[childKey] = {<EOL> ...actionHelpers,<EOL><EOL> state: childRoute,<EOL> router: childRouter,<EOL> actions: actionCreators,<EOL> getParam: createParamGetter(childRoute),<EOL><EOL> getChildNavigation: (grandChildKey) =><EOL> getChildNavigation(children[childKey], grandChildKey, () => {<EOL> const nav = getCurrentParentNavigation();<EOL> return nav && nav.getChildNavigation(childKey);<EOL> }),<EOL><EOL> isFocused: () => {<EOL> const currentNavigation = getCurrentParentNavigation();<EOL> if (!currentNavigation) {<EOL> return false;<EOL> }<EOL> const { routes, index } = currentNavigation.state;<EOL> if (!currentNavigation.isFocused()) {<EOL> return false;<EOL> }<EOL> if (routes[index].key === childKey) {<EOL> return true;<EOL> }<EOL> return false;<EOL> },<EOL> isFirstRouteInParent: () => isFirstRouteInParent,<EOL> dispatch: navigation.dispatch,<EOL> getScreenProps: navigation.getScreenProps,<EOL> dangerouslyGetParent: getCurrentParentNavigation,<EOL> addListener,<EOL> emit,<EOL> };<EOL><EOL> return children[childKey];<EOL> }<EOL>}<EOL><EOL>export default getChildNavigation;  <EOL><EOL>local Cryo = require(script.Parent.Parent.Cryo)<EOL>local getEventManager = require(script.Parent.getEventManager)<EOL>local getChildRouter = require(script.Parent.getChildRouter)<EOL>local getNavigationActionCreators = require(script.Parent.routers.getNavigationActionCreators)<EOL>local getChildrenNavigationCache = require(script.Parent.getChildrenNavigationCache)<EOL><EOL>local function createParamGetter(route)<EOL> return function(paramName, defaultValue)<EOL>  local params = route.params<EOL><EOL>  if params and params[paramName] ~= nil then<EOL>   return params[paramName]<EOL>  else<EOL>   return defaultValue<EOL>  end<EOL> end<EOL>end<EOL><EOL>local function getChildNavigation(navigation, childKey, getCurrentParentNavigation)<EOL> local children = getChildrenNavigationCache(navigation)<EOL><EOL> local childRouteIndex = Cryo.List.findWhere(navigation.state.routes, function(route)<EOL>  return route.key == childKey<EOL> end)<EOL><EOL> if not childRouteIndex then<EOL>  return nil<EOL> end<EOL> local childRoute = navigation.state.routes[childRouteIndex]<EOL><EOL> local requestedChild = children[childKey]<EOL><EOL> if requestedChild and requestedChild.state == childRoute then<EOL>  return requestedChild<EOL> end<EOL><EOL> local childRouter = getChildRouter(navigation.router, childRoute.routeName)<EOL><EOL> <EOL> <EOL> <EOL> <EOL> local focusedGrandChildRoute = nil<EOL> if childRoute.routes and type(childRoute.index) == "number" then<EOL>  focusedGrandChildRoute = childRoute.routes[childRoute.index]<EOL> end<EOL><EOL> local childRouterActionCreators = childRouter and<EOL>  childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) or {}<EOL><EOL> local actionCreators = Cryo.Dictionary.join(<EOL>  navigation.actions or {},<EOL>  navigation.router.getActionCreators(childRoute, navigation.state.key) or {},<EOL>  childRouterActionCreators or {},<EOL>  getNavigationActionCreators(childRoute) or {}<EOL> )<EOL><EOL> local actionHelpers = {}<EOL> for actionName, actionCreator in pairs(actionCreators) do<EOL>  actionHelpers[actionName] = function(...)<EOL>   local action = actionCreator(...)<EOL>   return navigation.dispatch(action)<EOL>  end<EOL> end<EOL><EOL> local isFirstRouteInParent = true;<EOL><EOL> local parentNavigation = getCurrentParentNavigation();<EOL><EOL> if parentNavigation then<EOL>  isFirstRouteInParent = Cryo.List.find(parentNavigation.state.routes, childRoute) == 1;<EOL> end<EOL><EOL> if requestedChild and requestedChild.isFirstRouteInParent() == isFirstRouteInParent then<EOL>  <EOL>  children[childKey] = Cryo.Dictionary.join(requestedChild, actionHelpers, {<EOL>   state = childRoute,<EOL>   router = childRouter,<EOL>   actions = actionCreators,<EOL>   getParam = createParamGetter(childRoute),<EOL>  })<EOL><EOL>  return children[childKey]<EOL> else<EOL>  <EOL>  local childSubscriber = getEventManager(childKey)<EOL><EOL>  children[childKey] = Cryo.Dictionary.join(actionHelpers, {<EOL>   state = childRoute,<EOL>   router = childRouter,<EOL>   actions = actionCreators,<EOL>   getParam = createParamGetter(childRoute),<EOL>   getChildNavigation = function(grandChildKey)<EOL>    return getChildNavigation(children[childKey], grandChildKey, function()<EOL>     local nav = getCurrentParentNavigation()<EOL>     return nav and nav.getChildNavigation(childKey) or nil<EOL>    end)<EOL>   end,<EOL>   isFocused = function()<EOL>    local currentNavigation = getCurrentParentNavigation()<EOL>    if not currentNavigation then<EOL>     return false<EOL>    end<EOL><EOL>    if not currentNavigation.isFocused() then<EOL>     return false<EOL>    end<EOL><EOL>    local state = currentNavigation.state<EOL>    local routes = state.routes<EOL>    local index = state.index<EOL><EOL>    if routes[index].key == childKey then<EOL>     return true<EOL>    end<EOL><EOL>    return false<EOL>   end,<EOL>   isFirstRouteInParent = function()<EOL>    return isFirstRouteInParent<EOL>   end,<EOL>   dispatch = navigation.dispatch,<EOL>   getScreenProps = navigation.getScreenProps,<EOL>   <EOL>   <EOL>   _dangerouslyGetParent = getCurrentParentNavigation,<EOL>   addListener = childSubscriber.addListener,<EOL>   emit = childSubscriber.emit,<EOL>  })<EOL><EOL>  return children[childKey]<EOL> end<EOL>end<EOL><EOL>return getChildNavigation