export default function getChildrenNavigationCache ( navigation ) { if ( !navigation ) { return { } ; } let childrenNavigationCache = navigation . _childrenNavigation | | ( navigation . _childrenNavigation = { } ) ; let childKeys = navigation . state . routes . map ( ( route ) => route . key ) ; Object . keys ( childrenNavigationCache ) . forEach ( ( cacheKey ) => { if ( !childKeys . includes ( cacheKey ) && !navigation . state . isTransitioning ) { delete childrenNavigationCache [ cacheKey ] ; } } ) ; return navigation . _childrenNavigation ; } 	 return function ( navigation ) if not navigation then return { } end if not navigation . _childrenNavigation then navigation . _childrenNavigation = { } end local childrenNavigationCache = navigation . _childrenNavigation local childKeys = { } for _ , route in ipairs ( navigation . state . routes or { } ) do childKeys [ route . key ] = true end if not navigation . state . isTransitioning then for cacheKey , _ in pairs ( childrenNavigationCache ) do if not childKeys [ cacheKey ] then childrenNavigationCache [ cacheKey ] = nil end end end return navigation . _childrenNavigation end
export default function getChildRouter ( router : any , routeName : string ) { if ( router . childRouters? . [ routeName ] ) { return router . childRouters [ routeName ] ; } const Component = router . getComponentForRouteName ( routeName ) ; return Component . router ; } 	 local validate = require ( script . Parent . utils . validate ) return function ( router , routeName ) validate ( type ( router ) == "table" , "router must be a table" ) validate ( type ( routeName ) == "string" , "routeName must be a string" ) if router . childRouters and router . childRouters [ routeName ] then return router . childRouters [ routeName ] end validate ( type ( router . getComponentForRouteName ) == "function" , "router . getComponentForRouteName must be a function if no child routers are specified" ) local component = router . getComponentForRouteName ( routeName ) if type ( component ) == "table" then return component . router else return nil end end
export default function getEventManager ( target ) { const listeners = { } ; const removeListener = ( type , callback ) => { const callbacks = listeners [ type ] ? listeners [ type ] [ target ] : undefined ; if ( !callbacks ) { return ; } const index = callbacks . indexOf ( callback ) ; callbacks . splice ( index , 1 ) ; } ; const addListener = ( type , callback ) => { listeners [ type ] = listeners [ type ] | | { } ; listeners [ type ] [ target ] = listeners [ type ] [ target ] | | [ ] ; listeners [ type ] [ target ] . push ( callback ) ; return { remove : ( ) => removeListener ( type , callback ) , } ; } ; return { addListener , emit : ( type , data ) => { const items = listeners [ type ] | | { } ; const callbacks = items [ target ] && items [ target ] . slice ( ) ; callbacks? . forEach ( ( cb ) => cb ( data ) ) ; } , } ; } 	 local root = script . Parent local Packages = root . Parent local Cryo = require ( Packages . Cryo ) local function getEventManager ( target ) local listeners = { } local function removeListener ( type , callback ) local callbacks = listeners [ type ] and listeners [ type ] [ target ] if not callbacks then return end local index = table . find ( callbacks , callback ) table . remove ( callbacks , index ) end local function addListener ( type , callback ) listeners [ type ] = listeners [ type ] or { } listeners [ type ] [ target ] = listeners [ type ] [ target ] or { } table . insert ( listeners [ type ] [ target ] , callback ) return { remove = function ( ) removeListener ( type , callback ) end , } end return { addListener = addListener , emit = function ( type , data ) local items = listeners [ type ] or { } local callbacks = items [ target ] and Cryo . List . join ( { } , items [ target ] ) if callbacks then for _ , callback in ipairs ( callbacks ) do callback ( data ) end end end , } end return getEventManager
import getNavigationActionCreators from ' . /routers/getNavigationActionCreators' ; import getChildNavigation from ' . /getChildNavigation' ; import getChildrenNavigationCache from ' . /getChildrenNavigationCache' ; export default function getNavigation ( router , state , dispatch , actionSubscribers , getScreenProps , getCurrentNavigation ) { const actions = router . getActionCreators ( state , null ) ; const navigation = { actions , router , state , dispatch , getScreenProps , getChildNavigation : ( childKey ) => getChildNavigation ( navigation , childKey , getCurrentNavigation ) , isFocused : ( childKey ) => { const { routes , index } = getCurrentNavigation ( ) . state ; if ( childKey == null | | routes [ index ] . key === childKey ) { return true ; } return false ; } , addListener : ( eventName , handler ) => { if ( eventName !== 'action' ) { return { remove : ( ) => { } } ; } actionSubscribers . add ( handler ) ; return { remove : ( ) => { actionSubscribers . delete ( handler ) ; } , } ; } , dangerouslyGetParent : ( ) => null , isFirstRouteInParent : ( ) => true , _childrenNavigation : getChildrenNavigationCache ( getCurrentNavigation ( ) ) , } ; const actionCreators = { ...  getNavigationActionCreators ( navigation . state ) , ...  actions , } ; Object . keys ( actionCreators ) . forEach ( ( actionName ) => { navigation [ actionName ] = ( ...  args ) => navigation . dispatch ( actionCreators [ actionName ] ( ...  args ) ) ; } ) ; return navigation ; } 	 local Cryo = require ( script . Parent . Parent . Cryo ) local Events = require ( script . Parent . Events ) local getNavigationActionCreators = require ( script . Parent . routers . getNavigationActionCreators ) local getChildNavigation = require ( script . Parent . getChildNavigation ) local getChildrenNavigationCache = require ( script . Parent . getChildrenNavigationCache ) return function ( router , state , dispatch , actionSubscribers , getScreenProps , getCurrentNavigation ) local actions = router . getActionCreators ( state , nil ) local navigation = { actions = actions , router = router , state = state , dispatch = dispatch , getScreenProps = getScreenProps , _dangerouslyGetParent = function ( ) return nil end , isFirstRouteInParent = function ( ) return true end , _childrenNavigation = getChildrenNavigationCache ( getCurrentNavigation ( ) ) , } function navigation . getChildNavigation ( childKey ) return getChildNavigation ( navigation , childKey , getCurrentNavigation ) end function navigation . isFocused ( childKey ) local currentState = getCurrentNavigation ( ) . state local routes = currentState . routes local index = currentState . index return childKey == nil or routes [ index ] . key == childKey end function navigation . addListener ( event , handler ) if event ~= Events . Action then return { remove = function ( ) end } else actionSubscribers [ handler ] = true return { remove = function ( ) actionSubscribers [ handler ] = nil end } end end local actionCreators = Cryo . Dictionary . join ( getNavigationActionCreators ( navigation . state ) , actions ) for actionName , _ in pairs ( actionCreators ) do navigation [ actionName ] = function ( ...  ) navigation . dispatch ( actionCreators [ actionName ] ( ...  ) ) end end return navigation end
export interface NavigationParams { [ key : string ] : any ; } export interface NavigationNavigateActionPayload { routeName : string ; params? : NavigationParams ; action? : NavigationNavigateAction ; key? : string ; } export interface NavigationNavigateAction extends NavigationNavigateActionPayload { type : 'Navigation/NAVIGATE' ; } export interface NavigationBackActionPayload { key? : string | null ; immediate? : boolean ; } export interface NavigationBackAction extends NavigationBackActionPayload { type : 'Navigation/BACK' ; } export interface NavigationInitActionPayload { params? : NavigationParams ; } export interface NavigationInitAction extends NavigationInitActionPayload { type : 'Navigation/INIT' ; } export interface NavigationSetParamsActionPayload { key : string ; params? : NavigationParams ; } export interface NavigationSetParamsAction extends NavigationSetParamsActionPayload { type : 'Navigation/SET_PARAMS' ; preserveFocus : true ; } export const BACK = 'Navigation/BACK' ; export const INIT = 'Navigation/INIT' ; export const NAVIGATE = 'Navigation/NAVIGATE' ; export const SET_PARAMS = 'Navigation/SET_PARAMS' ; export const back = ( payload : NavigationBackActionPayload = { } ) : NavigationBackAction => ( { type : BACK , key : payload . key , immediate : payload . immediate , } ) ; export const init = ( payload : NavigationInitActionPayload = { } ) => { const action : NavigationInitAction = { type : INIT , } ; if ( payload . params ) { action . params = payload . params ; } return action ; } ; export const navigate = ( payload : NavigationNavigateActionPayload ) : NavigationNavigateAction => { const action : NavigationNavigateAction = { type : NAVIGATE , routeName : payload . routeName , } ; if ( payload . params ) { action . params = payload . params ; } if ( payload . action ) { action . action = payload . action ; } if ( payload . key ) { action . key = payload . key ; } return action ; } ; export const setParams = ( payload : NavigationSetParamsActionPayload ) : NavigationSetParamsAction => ( { type : SET_PARAMS , key : payload . key , params : payload . params , preserveFocus : true , } ) ; 	 local NavigationSymbol = require ( script . Parent . NavigationSymbol ) local BACK_TOKEN = NavigationSymbol ( "BACK" ) local INIT_TOKEN = NavigationSymbol ( "INIT" ) local NAVIGATE_TOKEN = NavigationSymbol ( "NAVIGATE" ) local SET_PARAMS_TOKEN = NavigationSymbol ( "SET_PARAMS" ) NavigationActions provides shared constants and methods to construct actions that are dispatched to routers to cause a change in the route . ] ] local NavigationActions = { Back = BACK_TOKEN , Init = INIT_TOKEN , Navigate = NAVIGATE_TOKEN , SetParams = SET_PARAMS_TOKEN , } setmetatable ( NavigationActions , { __index = function ( self , key ) error ( ( "%q is not a valid member of NavigationActions" ) : format ( tostring ( key ) ) , 2 ) end , } ) function NavigationActions . back ( payload ) local data = payload or { } return { type = BACK_TOKEN , key = data . key , immediate = data . immediate , } end function NavigationActions . init ( payload ) local data = payload or { } return { type = INIT_TOKEN , params = data . params , } end function NavigationActions . navigate ( payload ) local data = payload or { } return { type = NAVIGATE_TOKEN , routeName = data . routeName , params = data . params , action = data . action , key = data . key , } end function NavigationActions . setParams ( payload ) local data = payload or { } return { type = SET_PARAMS_TOKEN , preserveFocus = true , key = data . key , params = data . params , } end return NavigationActions
import * as React from 'react' ; export default React . createContext ( undefined ) ; 	 local Roact = require ( script . Parent . Parent . Parent . Roact ) local NavigationContext = Roact . createContext ( nil ) return NavigationContext
import * as React from 'react' ; import withNavigation from ' . /withNavigation' ; const EventNameToPropName = { willFocus : 'onWillFocus' , didFocus : 'onDidFocus' , willBlur : 'onWillBlur' , didBlur : 'onDidBlur' , } ; const EventNames = Object . keys ( EventNameToPropName ) ; class NavigationEvents extends React . Component { componentDidMount ( ) { this . subscribeAll ( ) ; } componentDidUpdate ( prevProps ) { if ( this . props . navigation !== prevProps . navigation ) { this . removeAll ( ) ; this . subscribeAll ( ) ; } } componentWillUnmount ( ) { this . removeAll ( ) ; } getPropListener = ( eventName ) => this . props [ EventNameToPropName [ eventName ] ] ; subscribeAll ( ) { this . subscriptions = { } ; EventNames . forEach ( ( eventName ) => { this . subscriptions [ eventName ] = this . props . navigation . addListener ( eventName , ( ...  args ) => { const propListener = this . getPropListener ( eventName ) ; return propListener && propListener ( ...  args ) ; } ) ; } ) ; } removeAll ( ) { EventNames . forEach ( ( eventName ) => { this . subscriptions [ eventName ] . remove ( ) ; } ) ; } render ( ) { return null ; } } export default withNavigation ( NavigationEvents ) ; 	 local root = script . Parent . Parent local Packages = root . Parent local Roact = require ( Packages . Roact ) local withNavigation = require ( script . Parent . withNavigation ) local Events = require ( root . Events ) NavigationEvents providers a wrapper component that allows you to subscribe to the navigation lifecycle events without having to explicitly manage your own listener subscriptions . Usage : function MyComponent : init ( ) self . willFocus = function ( ) end self . didFocus = function ( ) end end function MyComponent : render ( ) return Roact . createElement ( RoactNavigation . NavigationEvents , { onWillFocus = self . willFocus , onDidFocus = self . didFocus , onWillBlur = self . willBlur , onDidBlur = self . didBlur , } ) end Remember that focus and blur events may be called more than once in the lifetime of a component . If you navigate away from a component and then come back later , it will receive willBlur/didBlur and then willFocus/didFocus events . Also remember that your event handlers must capture any self reference lexically , if necessary . ] ] local EventNameToPropName = { [ Events . WillFocus ] = "onWillFocus" , [ Events . DidFocus ] = "onDidFocus" , [ Events . WillBlur ] = "onWillBlur" , [ Events . DidBlur ] = "onDidBlur" , } local NavigationEvents = Roact . Component : extend ( "NavigationEvents" ) function NavigationEvents : didMount ( ) self : subscribeAll ( ) end function NavigationEvents : didUpdate ( prevProps ) if self . props . navigation ~= prevProps . navigation then self : removeAll ( ) self : subscribeAll ( ) end end function NavigationEvents : willUnmount ( ) self : removeAll ( ) end function NavigationEvents : getPropListener ( eventName ) return self . props [ EventNameToPropName [ eventName ] ] end function NavigationEvents : subscribeAll ( ) local navigation = self . props . navigation self . subscriptions = { } for symbol in pairs ( EventNameToPropName ) do self . subscriptions [ symbol ] = navigation . addListener ( symbol , function ( ...  ) local callback = self : getPropListener ( symbol ) if callback then callback ( ...  ) end end ) end end function NavigationEvents : removeAll ( ) for symbol in pairs ( EventNameToPropName ) do local sub = self . subscriptions [ symbol ] if sub then sub . remove ( ) self . subscriptions [ symbol ] = nil end end end function NavigationEvents : render ( ) return nil end return withNavigation ( NavigationEvents ) 
import * as React from 'react' ; import NavigationContext from ' . /NavigationContext' ; export default class SceneView extends React . PureComponent { render ( ) { const { screenProps , component : Component , navigation } = this . props ; return ( <NavigationContext . Provider value= { navigation } > <Component screenProps= { screenProps } navigation= { navigation } /> </NavigationContext . Provider> ) ; } } 	 local Roact = require ( script . Parent . Parent . Parent . Roact ) local NavigationContext = require ( script . Parent . NavigationContext ) local SceneView = Roact . PureComponent : extend ( "SceneView" ) function SceneView : render ( ) local screenProps = self . props . screenProps local component = self . props . component local navigation = self . props . navigation return Roact . createElement ( NavigationContext . Provider , { value = navigation , } , { Scene = Roact . createElement ( component , { screenProps = screenProps , navigation = navigation , } ) } ) end return SceneView
import * as React from 'react' ; import hoistStatics from 'hoist-non-react-statics' ; import invariant from ' . . /utils/invariant' ; import NavigationContext from ' . /NavigationContext' ; export default function withNavigation ( Component , config = { forwardRef : true } ) { class ComponentWithNavigation extends React . Component { static displayName = `withNavigation ( $ { Component . displayName | | Component . name } ) ` ; render ( ) { const navigationProp = this . props . navigation ; return ( <NavigationContext . Consumer> { ( navigationContext ) => { const navigation = navigationProp | | navigationContext ; invariant ( !!navigation , 'withNavigation can only be used on a view hierarchy of a navigator . The wrapped component is unable to get access to navigation from props or context . ' ) ; return ( <Component { ...  this . props } navigation= { navigation } ref= { config . forwardRef ? this . props . onRef : undefined } /> ) ; } } </NavigationContext . Consumer> ) ; } } return hoistStatics ( ComponentWithNavigation , Component ) ; } 	 local Packages = script . Parent . Parent . Parent local Cryo = require ( Packages . Cryo ) local Roact = require ( Packages . Roact ) local NavigationContext = require ( script . Parent . NavigationContext ) local validate = require ( script . Parent . Parent . utils . validate ) local function isComponent ( component ) local valueType = typeof ( component ) return valueType == "function" or valueType == "table" end withNavigation ( ) is a convenience function that you can use in your component's render function to access the navigation context object . For example : local MyComponent = Roact . Component : extend ( "MyComponent" ) function MyComponent : render ( ) local navigation = self . props . navigation return Roact . createElement ( "TextButton" , { [ Roact . Activated ] = function ( ) navigation . navigate ( "DetailPage" ) end } ) end return withNavigation ( MyComponent ) ] ] return function ( component , config ) assert ( isComponent ( component ) , "withNavigation must be called with a Roact component ( stateful or functional ) " ) config = config or { } if config . forwardRef == nil then config . forwardRef = true end return function ( props ) local navigationProp = props . navigation return Roact . createElement ( NavigationContext . Consumer , { render = function ( navigationContext ) local navigation = navigationProp or navigationContext validate ( navigation , "withNavigation and withNavigationFocus can only " . . "be used on a view hierarchy of a navigator . The wrapped component is " . . "unable to get access to navigation from props or context . " ) return Roact . createElement ( component , Cryo . Dictionary . join ( props , { navigation = navigation , [ Roact . Ref ] = config . forwardRef and props [ Roact . Ref ] or Cryo . None , } ) ) end , } ) end end
import * as React from 'react' ; import hoistStatics from 'hoist-non-react-statics' ; import withNavigation from ' . /withNavigation' ; export default function withNavigationFocus ( Component ) { class ComponentWithNavigationFocus extends React . Component { static displayName = `withNavigationFocus ( $ { Component . displayName | | Component . name } ) ` ; state = { isFocused : this . props . navigation . isFocused ( ) , } ; componentDidMount ( ) { const { navigation } = this . props ; this . subscriptions = [ navigation . addListener ( 'willFocus' , ( ) => this . setState ( { isFocused : true } ) ) , navigation . addListener ( 'willBlur' , ( ) => this . setState ( { isFocused : false } ) ) , ] ; } componentWillUnmount ( ) { this . subscriptions? . forEach ( ( sub ) => sub . remove ( ) ) ; } render ( ) { return ( <Component { ...  this . props } isFocused= { this . state . isFocused } ref= { this . props . onRef } /> ) ; } } return hoistStatics ( withNavigation ( ComponentWithNavigationFocus , { forwardRef : false } ) , Component ) ; } 	 withNavigationFocus ( ) is a convenience function that extends withNavigation ( ) , allowing your render function ( and therefor your subgraph ) to access the navigation context object AND an additional boolean that indicates whether or not the containing screen component is in focus . For example : function MyButtonComponent : render ( ) return withNavigationFocus ( function ( navigation , focused ) return Roact . createElement ( "TextButton" , { Visible = focused , [ Roact . Event . Activated ] = focused and function ( ) navigation . navigate ( "DetailPage" ) end , } ) end ) end This is very useful when writing generic components that need to work with the navigation system ( e . g . preventing buttons from navigating when a screen is not in focus so you don't cause double-navigation ) . Note that if you ONLY need the 'navigation' context object , it is recommended that you use withNavigation ( ) for performance reasons . ] ] local root = script . Parent . Parent local Packages = root . Parent local Roact = require ( Packages . Roact ) local Cryo = require ( Packages . Cryo ) local Events = require ( root . Events ) local withNavigation = require ( script . Parent . withNavigation ) local function isComponent ( component ) local valueType = typeof ( component ) return valueType == "function" or valueType == "table" end return function ( component ) assert ( isComponent ( component ) , "withNavigationFocus must be called with a Roact component ( stateful or functional ) " ) local NavigationFocusComponent = Roact . Component : extend ( "NavigationFocusComponent" ) function NavigationFocusComponent : init ( ) self . state = { isFocused = self . props . navigation . isFocused ( ) , } end function NavigationFocusComponent : didMount ( ) local navigation = self . props . navigation self . subscriptions = { navigation . addListener ( Events . WillFocus , function ( ) self : setState ( { isFocused = true , } ) end ) , navigation . addListener ( Events . WillBlur , function ( ) self : setState ( { isFocused = false , } ) end ) , } end function NavigationFocusComponent : willUnmount ( ) for _ , subscription in ipairs ( self . subscriptions ) do subscription . remove ( ) end end function NavigationFocusComponent : render ( ) return Roact . createElement ( component , Cryo . Dictionary . join ( self . props , { isFocused = self . state . isFocused , } ) ) end return withNavigation ( NavigationFocusComponent , { forwardRef = false } ) end
import invariant from ' . . /utils/invariant' ; import getScreenForRouteName from ' . /getScreenForRouteName' ; import validateScreenOptions from ' . /validateScreenOptions' ; function applyConfig ( configurer , navigationOptions , configProps ) { if ( typeof configurer === 'function' ) { return { ...  navigationOptions , ...  configurer ( { ...  configProps , navigationOptions , } ) , } ; } if ( typeof configurer === 'object' ) { return { ...  navigationOptions , ...  configurer , } ; } return navigationOptions ; } export default ( routeConfigs , navigatorScreenConfig ) => ( navigation , screenProps , theme ) => { const { state } = navigation ; const route = state ; invariant ( route . routeName && typeof route . routeName === 'string' , 'Cannot get config because the route does not have a routeName . ' ) ; const Component = getScreenForRouteName ( routeConfigs , route . routeName ) ; const routeConfig = routeConfigs [ route . routeName ] ; const routeScreenConfig = routeConfig === Component ? null : routeConfig . navigationOptions ; const componentScreenConfig = Component . navigationOptions ; const configOptions = { navigation , screenProps : screenProps | | { } , theme } ; let outputConfig = applyConfig ( navigatorScreenConfig , { } , configOptions ) ; outputConfig = applyConfig ( componentScreenConfig , outputConfig , configOptions ) ; outputConfig = applyConfig ( routeScreenConfig , outputConfig , configOptions ) ; validateScreenOptions ( outputConfig , route ) ; return outputConfig ; } ; 	 local Cryo = require ( script . Parent . Parent . Parent . Cryo ) local getScreenForRouteName = require ( script . Parent . getScreenForRouteName ) local validateScreenOptions = require ( script . Parent . validateScreenOptions ) local validate = require ( script . Parent . Parent . utils . validate ) local function applyConfig ( configurer , navigationOptions , configProps ) navigationOptions = navigationOptions or { } local configurerType = type ( configurer ) if configurerType == "function" then return Cryo . Dictionary . join ( navigationOptions , configurer ( Cryo . Dictionary . join ( configProps , { navigationOptions = navigationOptions } ) ) ) elseif configurerType == "table" then return Cryo . Dictionary . join ( navigationOptions , configurer ) else return navigationOptions end end return function ( routeConfigs , navigatorScreenConfig ) return function ( navigation , screenProps ) screenProps = screenProps or { } local route = navigation . state validate ( type ( route ) == "table" , "navigation . state must be a table" ) validate ( type ( route . routeName == "string" ) , "Cannot get config because the route does not have a routeName . " ) local component = getScreenForRouteName ( routeConfigs , route . routeName ) local routeConfig = routeConfigs [ route . routeName ] local routeScreenConfig = nil if routeConfig ~= component then routeScreenConfig = routeConfig . navigationOptions end local componentScreenConfig = type ( component ) == "table" and component . navigationOptions or { } local configOptions = { navigation = navigation , screenProps = screenProps , } local outputConfig = applyConfig ( navigatorScreenConfig , { } , configOptions ) outputConfig = applyConfig ( componentScreenConfig , outputConfig , configOptions ) outputConfig = applyConfig ( routeScreenConfig , outputConfig , configOptions ) validateScreenOptions ( outputConfig , route ) return outputConfig end end
import * as NavigationActions from ' . . /NavigationActions' ; import invariant from ' . . /utils/invariant' ; interface NavigationParams { [ key : string ] : any ; } const getNavigationActionCreators = ( route : any ) => { return { goBack : ( key? : string | null ) => { let actualizedKey = key ; if ( key === undefined && route . key ) { invariant ( typeof route . key === 'string' , 'key should be a string' ) ; actualizedKey = route . key ; } return NavigationActions . back ( { key : actualizedKey } ) ; } , navigate : ( navigateTo : string | NavigationActions . NavigationNavigateActionPayload , params? : NavigationParams , action? : NavigationActions . NavigationNavigateAction ) => { if ( typeof navigateTo === 'string' ) { return NavigationActions . navigate ( { routeName : navigateTo , params , action , } ) ; } invariant ( typeof navigateTo === 'object' , 'Must navigateTo an object or a string' ) ; invariant ( params == null , 'Params must not be provided to . navigate ( ) when specifying an object' ) ; invariant ( action == null , 'Child action must not be provided to . navigate ( ) when specifying an object' ) ; return NavigationActions . navigate ( navigateTo ) ; } , setParams : ( params? : NavigationParams ) => { invariant ( route . key && typeof route . key === 'string' , 'setParams cannot be called by root navigator' ) ; return NavigationActions . setParams ( { params , key : route . key } ) ; } , } ; } ; export default getNavigationActionCreators ; 	local NavigationActions = require ( script . Parent . Parent . NavigationActions ) local validate = require ( script . Parent . Parent . utils . validate ) return function ( route ) local result = { } function result . goBack ( key ) if key == nil and route . key then validate ( type ( route . key ) == "string" , " . goBack ( ) : key should be a string" ) key = route . key end return NavigationActions . back ( { key = key } ) end function result . navigate ( navigateTo , params , action ) if type ( navigateTo ) == "string" then return NavigationActions . navigate ( { routeName = navigateTo , params = params , action = action , } ) else validate ( type ( navigateTo ) == "table" , " . navigate ( ) : navigateTo must be a string or table" ) validate ( params == nil , " . navigate ( ) : params can only be provided with a string navigateTo value" ) validate ( action == nil , " . navigate ( ) : child action can only be provided with a string navigateTo value" ) return NavigationActions . navigate ( navigateTo ) end end function result . setParams ( params ) validate ( type ( route . key ) == "string" , " . setParams ( ) : cannot be called by the root navigator" ) return NavigationActions . setParams ( { params = params , key = route . key } ) end return result end
import { isValidElementType } from 'react-is' ; import invariant from ' . . /utils/invariant' ; export default function getScreenForRouteName ( routeConfigs , routeName ) { const routeConfig = routeConfigs [ routeName ] ; if ( !routeConfig ) { throw new Error ( `There is no route defined for key $ { routeName } . \ n` + `Must be one of : $ { Object . keys ( routeConfigs ) . map ( ( a ) => `'$ { a } '` ) . join ( ' , ' ) } ` ) ; } if ( routeConfig . screen ) { return routeConfig . screen ; } if ( typeof routeConfig . getScreen === 'function' ) { const screen = routeConfig . getScreen ( ) ; invariant ( isValidElementType ( screen ) , `The getScreen defined for route '$ { routeName } didn't return a valid ` + 'screen or navigator . \ n \ n' + 'Please pass it like this : \ n' + `$ { routeName } : { \ n getScreen : ( ) => require ( ' . /MyScreen' ) . default \ n } ` ) ; return screen ; } return routeConfig ; } 	 local root = script . Parent . Parent local Packages = root . Parent local Cryo = require ( Packages . Cryo ) local validate = require ( root . utils . validate ) local isValidScreenComponent = require ( root . utils . isValidScreenComponent ) return function ( routeConfigs , routeName ) validate ( type ( routeConfigs ) == "table" , "routeConfigs must be a table" ) validate ( type ( routeName ) == "string" , "routeName must be a string" ) local routeConfig = routeConfigs [ routeName ] if routeConfig == nil then local possibleRoutes = Cryo . List . map ( Cryo . Dictionary . keys ( routeConfigs ) , function ( name ) return ( "'%s'" ) : format ( name ) end ) local message = ( "There is no route defined for key %s . \ nMust be one of : %s" ) : format ( routeName , table . concat ( possibleRoutes , " , " ) ) error ( message , 2 ) end local routeConfigType = type ( routeConfig ) if routeConfigType == "table" then if routeConfig . screen ~= nil then validate ( isValidScreenComponent ( routeConfig . screen ) , "screen for key '%s' must be a valid Roact component . " , routeName ) return routeConfig . screen elseif type ( routeConfig . getScreen ) == "function" then local screen = routeConfig . getScreen ( ) validate ( isValidScreenComponent ( screen ) , "The getScreen defined for route '%s' didn't return a valid " . . "screen or navigator . \ n \ n" . . "Please pass it like this : \ n" . . "%s = { \ n getScreen : function ( ) return MyScreen end \ n } " , routeName , routeName ) return screen end end validate ( isValidScreenComponent ( routeConfig ) , "Value for key '%s' must be a route config table or a valid Roact component . " , routeName ) return routeConfig end
export const POP = 'Navigation/POP' ; export const POP_TO_TOP = 'Navigation/POP_TO_TOP' ; export const PUSH = 'Navigation/PUSH' ; export const RESET = 'Navigation/RESET' ; export const REPLACE = 'Navigation/REPLACE' ; export const COMPLETE_TRANSITION = 'Navigation/COMPLETE_TRANSITION' ; export const pop = ( payload ) => ( { type : POP , ...  payload , } ) ; export const popToTop = ( payload ) => ( { type : POP_TO_TOP , ...  payload , } ) ; export const push = ( payload ) => ( { type : PUSH , ...  payload , } ) ; export const reset = ( payload ) => ( { type : RESET , key : null , ...  payload , } ) ; export const replace = ( payload ) => ( { type : REPLACE , ...  payload , } ) ; export const completeTransition = ( payload ) => ( { type : COMPLETE_TRANSITION , preserveFocus : true , ...  payload , } ) ; 	 local root = script . Parent . Parent local Packages = root . Parent local Cryo = require ( Packages . Cryo ) local NavigationSymbol = require ( root . NavigationSymbol ) local POP_TOKEN = NavigationSymbol ( "POP" ) local POP_TO_TOP_TOKEN = NavigationSymbol ( "POP_TO_TOP" ) local PUSH_TOKEN = NavigationSymbol ( "PUSH" ) local RESET_TOKEN = NavigationSymbol ( "RESET" ) local REPLACE_TOKEN = NavigationSymbol ( "REPLACE" ) local COMPLETE_TRANSITION_TOKEN = NavigationSymbol ( "COMPLETE_TRANSITION" ) StackActions provides shared constants and methods to construct actions that are dispatched to routers to cause a change in the route . These actions are specific to Stack navigation . See NavigationActions if you need to use more general APIs . ] ] local StackActions = { Pop = POP_TOKEN , PopToTop = POP_TO_TOP_TOKEN , Push = PUSH_TOKEN , Reset = RESET_TOKEN , Replace = REPLACE_TOKEN , CompleteTransition = COMPLETE_TRANSITION_TOKEN , } setmetatable ( StackActions , { __index = function ( self , key ) error ( ( "%q is not a valid member of StackActions" ) : format ( tostring ( key ) ) , 2 ) end , } ) function StackActions . pop ( payload ) return Cryo . Dictionary . join ( { type = POP_TOKEN } , payload or { } ) end function StackActions . popToTop ( payload ) return Cryo . Dictionary . join ( { type = POP_TO_TOP_TOKEN } , payload or { } ) end function StackActions . push ( payload ) return Cryo . Dictionary . join ( { type = PUSH_TOKEN } , payload or { } ) end function StackActions . reset ( payload ) return Cryo . Dictionary . join ( { type = RESET_TOKEN } , payload or { } ) end function StackActions . replace ( payload ) return Cryo . Dictionary . join ( { type = REPLACE_TOKEN , preserveFocus = true } , payload or { } ) end function StackActions . completeTransition ( payload ) return Cryo . Dictionary . join ( { type = COMPLETE_TRANSITION_TOKEN , preserveFocus = true } , payload or { } ) end return StackActions
export const JUMP_TO = 'Navigation/JUMP_TO' ; export const jumpTo = ( payload : { routeName : string ; key : string ; params? : object ; } ) => ( { type : JUMP_TO , preserveFocus : true , ...  payload , } ) ; 	local Cryo = require ( script . Parent . Parent . Parent . Cryo ) local NavigationSymbol = require ( script . Parent . Parent . NavigationSymbol ) local JUMP_TO_TOKEN = NavigationSymbol ( "JUMP_TO" ) local SwitchActions = { JumpTo = JUMP_TO_TOKEN , } setmetatable ( SwitchActions , { __index = function ( self , key ) error ( ( "%q is not a valid member of SwitchActions" ) : format ( tostring ( key ) ) , 2 ) end , } ) function SwitchActions . jumpTo ( payload ) return Cryo . Dictionary . join ( { type = JUMP_TO_TOKEN , preserveFocus = true } , payload or { } ) end return SwitchActions
import SwitchRouter from ' . /SwitchRouter' ; import withDefaultValue from ' . . /utils/withDefaultValue' ; export default ( routeConfigs , config = { } ) => { config = { ...  config } ; config = withDefaultValue ( config , 'resetOnBlur' , false ) ; config = withDefaultValue ( config , 'backBehavior' , 'initialRoute' ) ; const switchRouter = SwitchRouter ( routeConfigs , config ) ; return switchRouter ; } ; 	 local Cryo = require ( script . Parent . Parent . Parent . Cryo ) local SwitchRouter = require ( script . Parent . SwitchRouter ) local BackBehavior = require ( script . Parent . Parent . BackBehavior ) return function ( routeArray , config ) local switchConfig = { resetOnBlur = false , backBehavior = BackBehavior . InitialRoute , } if config then switchConfig = Cryo . Dictionary . join ( switchConfig , config ) end return SwitchRouter ( routeArray , switchConfig ) end
import { isValidElementType } from 'react-is' ; import invariant from ' . . /utils/invariant' ; function validateRouteConfigMap ( routeConfigs ) { const routeNames = Object . keys ( routeConfigs ) ; invariant ( routeNames . length > 0 , 'Please specify at least one route when configuring a navigator . ' ) ; routeNames . forEach ( ( routeName ) => { const routeConfig = routeConfigs [ routeName ] ; const screenComponent = getScreenComponent ( routeConfig ) ; if ( !screenComponent | | ( !isValidElementType ( screenComponent ) && !routeConfig . getScreen ) ) { throw new Error ( `The component for route '$ { routeName } ' must be a React component . For example : import MyScreen from ' . /MyScreen' ; ...  $ { routeName } : MyScreen , } You can also use a navigator : import MyNavigator from ' . /MyNavigator' ; ...  $ { routeName } : MyNavigator , } ` ) ; } if ( routeConfig . screen && routeConfig . getScreen ) { throw new Error ( `Route '$ { routeName } ' should declare a screen or a getScreen , not both . ` ) ; } } ) ; } function getScreenComponent ( routeConfig ) { if ( !routeConfig ) { return null ; } return routeConfig . screen ? routeConfig . screen : routeConfig ; } export default validateRouteConfigMap ; 	 local root = script . Parent . Parent local validate = require ( root . utils . validate ) local isValidScreenComponent = require ( root . utils . isValidScreenComponent ) local function getScreenComponent ( routeConfig ) if not routeConfig then return nil end if type ( routeConfig ) == "table" and routeConfig . screen then return routeConfig . screen end return routeConfig end This utility checks to make sure that configs passed to a router are in the correct format . Example : routeConfigs = { routeNameEx1 = Roact . Function/Stateful_Component , routeNameEx2 = { screen = Roact . Function/Stateful_Component , } , routeNameEx3 = { getScreen = function ( ) return Roact . Function/Stateful_Component end } routeNameEx4 = AnotherRoactNavigator } ] ] return function ( routeConfigs ) validate ( type ( routeConfigs ) == "table" , "routeConfigs must be a table" ) validate ( next ( routeConfigs ) ~= nil , "Please specify at least one route when configuring a navigator . " ) for routeName , routeConfig in pairs ( routeConfigs ) do local screenComponent = getScreenComponent ( routeConfig ) local tableRouteConfig = type ( routeConfig ) == "table" validate ( isValidScreenComponent ( screenComponent ) or ( tableRouteConfig and type ( routeConfig . getScreen ) == "function" ) , "The component for route '%s' must be a Roact component or table with 'getScreen' . " . . [ [ For example : local MyScreen = require ( script . Parent . MyScreen ) ...  %s = MyScreen , } You can also use a navigator : local MyNavigator = require ( script . Parent . MyNavigator ) ...  %s = MyNavigator , } ] ] , routeName , routeName , routeName ) if tableRouteConfig then validate ( routeConfig . screen == nil or routeConfig . getScreen == nil , "Route '%s' should declare a screen or a getScreen , not both . " , routeName ) end end return routeConfigs end
const deprecatedKeys = [ 'tabBar' ] ; export default ( screenOptions , route ) => { const keys = Object . keys ( screenOptions ) ; const deprecatedKey = keys . find ( ( key ) => deprecatedKeys . includes ( key ) ) ; if ( typeof screenOptions . title === 'function' ) { throw new Error ( [ ` \ `title \ ` cannot be defined as a function in navigation options for \ `$ { route . routeName } \ ` screen . \ n` , 'Try replacing the following : ' , ' { ' , ' title : ( { state } ) => state ...  ' , ' } ' , '' , 'with : ' , ' ( { navigation } ) => ( { ' , ' title : navigation . state ...  ' , ' } ) ' , ] . join ( ' \ n' ) ) ; } if ( deprecatedKey && typeof screenOptions [ deprecatedKey ] === 'function' ) { throw new Error ( [ ` \ `$ { deprecatedKey } \ ` cannot be defined as a function in navigation options for \ `$ { route . routeName } \ ` screen . \ n` , 'Try replacing the following : ' , ' { ' , ` $ { deprecatedKey } : ( { state } ) => ( { ` , ' key : state ...  ' , ' } ) ' , ' } ' , '' , 'with : ' , ' ( { navigation } ) => ( { ' , ` $ { deprecatedKey } Key : navigation . state ...  ` , ' } ) ' , ] . join ( ' \ n' ) ) ; } if ( deprecatedKey && typeof screenOptions [ deprecatedKey ] === 'object' ) { throw new Error ( [ `Invalid key \ `$ { deprecatedKey } \ ` defined in navigation options for \ `$ { route . routeName } \ ` screen . ` , ' \ n' , 'Try replacing the following navigation options : ' , ' { ' , ` $ { deprecatedKey } : { ` , ...  Object . keys ( screenOptions [ deprecatedKey ] ) . map ( ( key ) => ` $ { key } : ...  , ` ) , ' } , ' , ' } ' , ' \ n' , 'with : ' , ' { ' , ...  Object . keys ( screenOptions [ deprecatedKey ] ) . map ( ( key ) => ` $ { deprecatedKey + key [ 0 ] . toUpperCase ( ) + key . slice ( 1 ) } : ...  , ` ) , ' } ' , ] . join ( ' \ n' ) ) ; } } ; 	local validate = require ( script . Parent . Parent . utils . validate ) return function ( screenOptions , route ) validate ( type ( screenOptions ) == "table" , "screenOptions must be a table" ) validate ( type ( route ) == "table" , "route must be a table" ) validate ( type ( route . routeName ) == "string" , "route . routeName must be a string" ) validate ( type ( screenOptions . title ) ~= "function" , "title cannot be defined as a function in navigation options for screen '%s'" , route . routeName ) end
